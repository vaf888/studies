//------------------------------------------------
// description..: assync + future
// version......: v0
// author.......: Antonio Fernandes
//------------------------------------------------

#include <iostream>  	// std::cout, std::endl
#include <cassert>
#include <cstring>
#include <chrono>
#include <ctime>
#include <vector>
#include <thread>
#include <cstdlib>

using namespace std;

/*
    core guidelines C.20 C.21

	AVOID DEFINING ANY DEFAULT FUNCTION (see below)
	OR DEFINE THEM AT ALL

    C++ provides six default operations, sometimes also called special functions, for managing the 
    lifecycle of an object -> RuleOfZeroFiveSix; the 6 functions:

    a default constructor: X()
    a copy constructor: X(const X&)
    a copy assignment: operator=(const X&)
    a move constructor: X(X&&)
    a move assignment: operator=(X&&)
    a destructor: ~X()

    The default operations are related. 
    This means:
    a) if you implement or =delete one of them, you have to think about the five others. 
       (*)  The word implement may seem a little bit confusing. 
       (**) For the default constructor it means that you can define it or request if from 
            the compiler:
            X(){};          // explicitly defined
            X() = default;  // requested from the compiler

    b) This rule holds also for the five other default operations


    c)"the rule of zero" -> C.20: If you can avoid defining any default operations, do  
     That means, if your class needs no default operations because all its members have the six 
     special functions, you are done.
     e.g.:
		struct Named_map 
		{
			public:
			    // ... no default operations declared ...
			private:
			    string name;
			    map<int, int> rep;
		};

		Named_map nm;        // default construct
		Named_map nm2 {nm};  // copy construct  

	d) "the rule of five" -> C.21: If you define or =delete any default operation, 
	   define or =delete them all
	   (*) Because we have to define or =delete all six of them
	   E.g.:

		struct M2 
		{   // bad: incomplete set of default operations
			public:
			    // ...
			    // ... no copy or move operations ...
			    ~M2() { delete[] rep; }
			private:
			    pair<int, int>* rep;  // zero-terminated set of pairs
		};

		void use()
		{
		    M2 x;
		    M2 y;
		    // ...
		    x = y;   // the default assignment
		    // ...
		}

		(*) What is strange about this example? 
		    -First, the destructor deletes rep, which was never initialised. 
		    -Second, and that is more serious: the default copy assignment operation  (x  =  y) 
		     in the last line copies all members of M2. This means, in particular, that pointer 
		     rep will be copied (shallow copy). 
		     Hence, the destructor for x and y will be called and we get undefined behaviour 
		     because of double deletion.


	e) C.22: Make default operations consistent
	   -This rule is kind of related to the previous rule. If you implement the default operations 
	    with different semantic, the users of the class may become very confused. 
	   -This is the reason, I constructed the class Strange.To observe the odd behaviour, 
	    Strange includes a pointer to int

	    struct Strange
	    { 
  
		  Strange(): p(new int(2011)){}
		    
		  // deep copy 
		  Strange(const Strange& a) : p(new int(*(a.p))){}    // (1)
		  
		  // shallow copy
		  Strange& operator=(const Strange& a){               // (2)
		    p = a.p;
		    return *this;
  		}  
   
  int* p;
    
};

(*) The class Strange has a copy constructor (1) and a copy assignment operator (2). 
    -The copy constructor uses deep copy and the assignment operator shallow copy. 
    -Most of the times you want deep copy semantic (value semantic) for your types but 
     you probably never want to have different semantic for this two related operations.
    -The difference is, that deep copy semantic creates two separated new objects 
     (p(new int(*(a.p)) while shallow copy semantic just copies the pointer (p = a.p). 
    
*/


//----------------------------------------------------------------------
// default member functions created by the compiler
struct MyType
{

	//DEFAULT FUNCTIONS GENERATED BY THE COMPILER (6) !!!!!!!!!

	MyType();	// DEFAULT CONSTRUCTOR

	MyType(const MyType & t); // COPY CONSTRUCTOR

	MyType(MyType && t);      // MOVE CONSTRUCTOR

	MyType &operator=(const MyType & other); // COPY ASSIGNMENT

	MyType &operator=(MyType && other);	     // MOVE ASSIGNMENT

	~MyType();	// DESTRUCTOR
};

//TODO: implement method bodies !!!!


struct S
{
	// here a define the destructor ONLY -> the compiler WILL NO
	// GENERATE THE OTHERS FOR YOU
	// (you should generate all the others - otherwise code will be ineficient
	//  for instance: move will not be used - in the case of the emplace-back below)
	~S() {}

	std::string s;
};

//----------------------------------------------------------------------
int main()
{
	std::vector<S> ss;

	for(int i =0; i <100; ++i)
	{
		ss.emplace_back();
	}

	return 0;
}

